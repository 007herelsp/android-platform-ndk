#!/usr/bin/env ruby

# Copyright (c) 2011-2015, 2017 CrystaX.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
#
#    1. Redistributions of source code must retain the above copyright notice, this list of
#       conditions and the following disclaimer.
#
#    2. Redistributions in binary form must reproduce the above copyright notice, this list
#       of conditions and the following disclaimer in the documentation and/or other materials
#       provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY CrystaX ''AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL CrystaX OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# The views and conclusions contained in the software and documentation are those of the
# authors and should not be interpreted as representing official policies, either expressed
# or implied, of CrystaX.

require 'fileutils'
require 'pathname'
require 'digest'

MYNAME = Pathname.new(File.expand_path(__FILE__)).relative_path_from(Pathname.new(File.expand_path('../..', __FILE__))).to_s

TOPDIR = File.realpath(File.join(File.dirname(__FILE__), '..'))
SRCDIR = File.realpath(File.join(TOPDIR, '../../../../vendor/libkqueue'))

PRIVATEDIR = File.join(TOPDIR, 'gen', 'libkqueue')
PUBLICDIR  = File.join(TOPDIR, 'include')

class Generator
    def initialize
        @files = {}
    end

    def license
        @license = File.read(File.join(TOPDIR, 'LICENSE')).split("\n").map(&:chomp) if @license.nil?
        @license
    end
    private :license

    def relpath(path, from)
        Pathname.new(path).relative_path_from(Pathname.new(from)).to_s
    end
    private :relpath

    def add(f, options = {}, &block)
        raise "No such file: #{f}" if !File.exists?(File.join(SRCDIR, f)) && !block_given?
        raise "File #{f} already added" if @files.has_key?(f)
        ff = {options: options}
        ff[:generator] = block if block_given?
        @files[f] = ff
    end

    def generate
        total = @files.size
        current = 0
        @files.each do |f,e|
            options = e[:options]
            generator = e[:generator]

            if generator.nil?
                src = File.join(SRCDIR, f)
            else
                src = __FILE__
            end
            mdst = File.join(options[:public] ? File.join(PUBLICDIR, 'crystax', 'libkqueue') : PRIVATEDIR, File.dirname(f), "mangled-#{File.basename(f)}")

            if options[:public]
                f = f.split('/')[1..-1].join('/') if f =~ /^include\//
                dst = File.join(PUBLICDIR, f)
            else
                dst = File.join(PRIVATEDIR, f)
            end

            symdst = []
            if options[:symlink]
                symsrc = options[:symlink]
                symsrc = [symsrc] unless symsrc.is_a?(Array)
                symdst += symsrc.map { |es| File.join(PRIVATEDIR, es) }
            end

            next if File.exists?(dst) && File.exists?(mdst) &&
                File.mtime(dst)  >= File.mtime(mdst) &&
                File.mtime(mdst) >= File.mtime(src) &&
                File.mtime(dst)  >= File.mtime(__FILE__) &&
                File.mtime(mdst) >= File.mtime(__FILE__)

            current += 1
            puts "GEN  [#{current}/#{total}] #{f}"

            FileUtils.rm_f mdst
            FileUtils.mkdir_p File.dirname(mdst)
            if generator.nil?
                FileUtils.cp src, mdst
            else
                File.open(mdst, "w") do |ff|
                    generator.call(ff)
                end
            end

            FileUtils.mkdir_p File.dirname(dst)
            File.open(dst, "w") do |df|
                df.puts "/* WARNING!!! THIS IS AUTO-GENERATED FILE!!! DO NOT MODIFY IT MANUALLY!!! */"
                df.puts "/* GENERATED BY: $CRYSTAX/#{MYNAME} */"
                df.puts ""

                df.puts "/*"
                license.each do |line|
                    df.puts " * #{line}".rstrip
                end
                df.puts " */"

                guard = "__CRYSTAX_INCLUDE_#{Digest::SHA256.new.update(relpath(dst, TOPDIR)).hexdigest}".upcase
                df.puts ""
                df.puts "#ifndef #{guard}"
                df.puts "#define #{guard}"

                df.puts ""
                if options[:public]
                    df.puts "#include <crystax/id.h>"
                    df.puts "#include <#{relpath(mdst, File.join(TOPDIR, 'include'))}>"
                else
                    df.puts "#include \"#{File.basename(mdst)}\""
                end

                df.puts ""
                df.puts "#endif /* #{guard} */"
            end

            symdst.each do |sd|
                FileUtils.mkdir_p File.dirname(sd)
                FileUtils.rm_f sd
                FileUtils.ln_s mdst, sd
            end
        end
    end
end

g = Generator.new

g.add "config.h", symlink: "src/common/config.h" do |f|
    f.puts <<-EOF
#include <android/api-level.h>

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if you have the <sys/epoll.h> header file. */
#define HAVE_SYS_EPOLL_H 1

/* Define to 1 if you have the <sys/eventfd.h> header file. */
#define HAVE_SYS_EVENTFD_H 1

/* Define to 1 if you have the <sys/inotify.h> header file. */
#define HAVE_SYS_INOTIFY_H 1

/* Define to 1 if you have the <sys/signalfd.h> header file. */
#if __ANDROID_API__ >= 21
#define HAVE_SYS_SIGNALFD_H 1
#endif

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/timerfd.h> header file. */
#if __ANDROID_API__ >= 21
#define HAVE_SYS_TIMERFD_H 1
#endif

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1
    EOF
end

g.add "include/sys/event.h", public: true

g.add "src/common/alloc.h"
g.add "src/common/debug.h"
g.add "src/common/private.h"
g.add "src/common/queue.h"
g.add "src/common/tree.h"
g.add "src/linux/platform.h"
g.add "src/posix/platform.h"

g.add "src/common/filter.c"
g.add "src/common/kevent.c"
g.add "src/common/knote.c"
g.add "src/common/kqueue.c"
g.add "src/common/map.c"

g.add "src/posix/platform.c"

g.add "src/linux/platform.c"
g.add "src/linux/read.c"
g.add "src/linux/signal.c"
g.add "src/linux/timer.c"
g.add "src/linux/user.c"
g.add "src/linux/vnode.c"
g.add "src/linux/write.c"

g.generate
